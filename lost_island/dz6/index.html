<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>AR Чотирикутник на маркерах</title>
    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.0/dist/mindar-image-aframe.prod.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        a-scene {
            width: 100%;
            height: 100vh;
        }
        #info-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 10px;
            max-width: 300px;
            z-index: 10000;
        }
        .marker-label {
            font-size: 0.5em;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 0.2em;
            border-radius: 0.2em;
            white-space: nowrap;
        }
        #debug-info {
            font-size: 0.8em;
            color: #ff9900;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <a-scene mindar-image="imageTargetSrc: targets.mind; autoStart: true;" 
             vr-mode-ui="enabled: false" 
             renderer="colorManagement: true;"
             loading-screen="enabled: false;">

        <a-assets>
            <img id="markerA" src="markerA.png">
            <img id="markerB" src="markerB.png">
            <img id="markerC" src="markerC.png">
            <img id="markerD" src="markerD.png">
        </a-assets>

        <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>

        <!-- Маркери -->
        <a-entity mindar-image-target="targetIndex: 0" id="markerA-entity">
            <a-plane src="#markerA" width="0.5" height="0.5" position="0 0 0" rotation="-90 0 0"></a-plane>
            <a-entity position="0 0.01 0" text="value: A; align: center; color: white; width: 5" class="marker-label"></a-entity>
        </a-entity>

        <a-entity mindar-image-target="targetIndex: 1" id="markerB-entity">
            <a-plane src="#markerB" width="0.5" height="0.5" position="0 0 0" rotation="-90 0 0"></a-plane>
            <a-entity position="0 0.01 0" text="value: B; align: center; color: white; width: 5" class="marker-label"></a-entity>
        </a-entity>

        <a-entity mindar-image-target="targetIndex: 2" id="markerC-entity">
            <a-plane src="#markerC" width="0.5" height="0.5" position="0 0 0" rotation="-90 0 0"></a-plane>
            <a-entity position="0 0.01 0" text="value: C; align: center; color: white; width: 5" class="marker-label"></a-entity>
        </a-entity>

        <a-entity mindar-image-target="targetIndex: 3" id="markerD-entity">
            <a-plane src="#markerD" width="0.5" height="0.5" position="0 0 0" rotation="-90 0 0"></a-plane>
            <a-entity position="0 0.01 0" text="value: D; align: center; color: white; width: 5" class="marker-label"></a-entity>
        </a-entity>

        <!-- Лінії між маркерами -->
        <a-entity id="lines"></a-entity>

        <!-- Панель інформації -->
        <div id="info-panel">
            <h3>Геометричні обчислення</h3>
            <p id="perimeter">Периметр: -</p>
            <p id="areas">Площі трикутників: -</p>
            <p id="debug-info">Статус: Ініціалізація...</p>
        </div>
    </a-scene>

    <script>
        // Глобальний об'єкт для відстеження стану
        const ARState = {
            markers: {
                A: { entity: null, position: null, detected: false },
                B: { entity: null, position: null, detected: false },
                C: { entity: null, position: null, detected: false },
                D: { entity: null, position: null, detected: false }
            },
            sceneReady: false,
            trackingStarted: false
        };

        // Функція ініціалізації сцени
        function initScene() {
            const scene = document.querySelector('a-scene');
            
            scene.addEventListener('loaded', function() {
                // Отримуємо посилання на маркери
                ARState.markers.A.entity = document.getElementById('markerA-entity');
                ARState.markers.B.entity = document.getElementById('markerB-entity');
                ARState.markers.C.entity = document.getElementById('markerC-entity');
                ARState.markers.D.entity = document.getElementById('markerD-entity');
                
                // Перевіряємо, чи всі маркери знайдені
                const allMarkersFound = Object.values(ARState.markers).every(m => m.entity);
                
                if (!allMarkersFound) {
                    updateDebugInfo("Помилка: Не всі маркери знайдені в DOM");
                    console.error("Деякі маркери не знайдені:", ARState.markers);
                    return;
                }
                
                ARState.sceneReady = true;
                updateDebugInfo("Сцена готова. Очікування маркерів...");
                
                // Запускаємо перевірку маркерів
                setInterval(checkMarkers, 100);
            });
            
            // Додаткові слухачі подій MindAR
            scene.addEventListener('mindar-target-found', event => {
                if (!ARState.trackingStarted) {
                    ARState.trackingStarted = true;
                    updateDebugInfo("Відстеження розпочато");
                }
            });
            
            scene.addEventListener('mindar-target-lost', event => {
                updateDebugInfo("Маркери втрачено. Пошук...");
            });
        }

        // Функція перевірки стану маркерів
        function checkMarkers() {
            if (!ARState.sceneReady) return;
            
            let anyDetected = false;
            let detectedCount = 0;
            
            // Перевіряємо кожен маркер
            for (const [key, marker] of Object.entries(ARState.markers)) {
                try {
                    const entity = marker.entity;
                    
                    // Перевірка наявності та видимості маркера
                    if (entity && entity.object3D && entity.object3D.visible) {
                        const position = new THREE.Vector3();
                        entity.object3D.getWorldPosition(position);
                        
                        marker.position = position;
                        marker.detected = true;
                        anyDetected = true;
                        detectedCount++;
                    } else {
                        marker.detected = false;
                        marker.position = null;
                    }
                } catch (error) {
                    console.error(`Помилка при обробці маркера ${key}:`, error);
                    marker.detected = false;
                    marker.position = null;
                }
            }
            
            // Оновлюємо візуалізацію
            if (anyDetected) {
                updateLines();
                updateCalculations();
                updateDebugInfo(`Виявлено маркерів: ${detectedCount}/4`);
            } else if (ARState.trackingStarted) {
                updateDebugInfo("Маркери не виявлені. Пошук...");
            }
        }

        // Функція оновлення ліній між маркерами
        function updateLines() {
            const linesContainer = document.getElementById('lines');
            linesContainer.innerHTML = '';
            
            // Малюємо лінії між виявленими маркерами
            const connections = [
                ['A', 'B'], ['B', 'C'], ['C', 'D'], ['D', 'A']
            ];
            
            connections.forEach(([startKey, endKey]) => {
                const startMarker = ARState.markers[startKey];
                const endMarker = ARState.markers[endKey];
                
                if (startMarker.detected && endMarker.detected) {
                    const p1 = startMarker.position;
                    const p2 = endMarker.position;
                    
                    // Обчислюємо параметри лінії
                    const length = Math.sqrt(
                        Math.pow(p2.x - p1.x, 2) + 
                        Math.pow(p2.y - p1.y, 2) + 
                        Math.pow(p2.z - p1.z, 2)
                    );
                    
                    const midpoint = {
                        x: (p1.x + p2.x) / 2,
                        y: (p1.y + p2.y) / 2,
                        z: (p1.z + p2.z) / 2
                    };
                    
                    // Напрямок лінії
                    const angle = Math.atan2(p2.z - p1.z, p2.x - p1.x) * (180 / Math.PI);
                    
                    // Створюємо лінію
                    const line = document.createElement('a-entity');
                    line.setAttribute('geometry', {
                        primitive: 'cylinder',
                        radius: 0.01,
                        height: length
                    });
                    line.setAttribute('material', {
                        color: '#00FF00',
                        opacity: 0.8
                    });
                    line.setAttribute('position', {
                        x: midpoint.x,
                        y: midpoint.y + 0.01,
                        z: midpoint.z
                    });
                    line.setAttribute('rotation', {
                        x: 0,
                        y: -angle + 90,
                        z: 0
                    });
                    
                    linesContainer.appendChild(line);
                }
            });
        }

        // Функція оновлення обчислень
        function updateCalculations() {
            const detectedCount = Object.values(ARState.markers).filter(m => m.detected).length;
            
            // Якщо виявлено не всі маркери
            if (detectedCount < 4) {
                document.getElementById('perimeter').textContent = `Периметр: Виявлено ${detectedCount}/4 маркерів`;
                document.getElementById('areas').textContent = "Площі: Потрібно всі 4 маркери";
                return;
            }
            
            // Обчислюємо периметр
            let perimeter = 0;
            const sides = [
                distance(ARState.markers.A.position, ARState.markers.B.position),
                distance(ARState.markers.B.position, ARState.markers.C.position),
                distance(ARState.markers.C.position, ARState.markers.D.position),
                distance(ARState.markers.D.position, ARState.markers.A.position)
            ];
            
            perimeter = sides.reduce((sum, side) => sum + side, 0);
            document.getElementById('perimeter').textContent = `Периметр: ${perimeter.toFixed(2)} м`;
            
            // Обчислюємо площі трикутників
            const triangles = [
                {name: 'ABC', points: ['A', 'B', 'C']},
                {name: 'ABD', points: ['A', 'B', 'D']},
                {name: 'ACD', points: ['A', 'C', 'D']},
                {name: 'BCD', points: ['B', 'C', 'D']}
            ];
            
            let areasText = "Площі трикутників:<br>";
            triangles.forEach(triangle => {
                const area = triangleArea(
                    ARState.markers[triangle.points[0]].position,
                    ARState.markers[triangle.points[1]].position,
                    ARState.markers[triangle.points[2]].position
                );
                areasText += `${triangle.name}: ${area.toFixed(2)} м²<br>`;
            });
            
            document.getElementById('areas').innerHTML = areasText;
        }

        // Допоміжні функції
        function distance(p1, p2) {
            return Math.sqrt(
                Math.pow(p2.x - p1.x, 2) + 
                Math.pow(p2.y - p1.y, 2) + 
                Math.pow(p2.z - p1.z, 2)
            );
        }

        function triangleArea(a, b, c) {
            const ab = distance(a, b);
            const bc = distance(b, c);
            const ca = distance(c, a);
            
            const s = (ab + bc + ca) / 2;
            return Math.sqrt(Math.max(0, s * (s - ab) * (s - bc) * (s - ca)));
        }

        function updateDebugInfo(message) {
            document.getElementById('debug-info').textContent = message;
            console.log(message);
        }

        // Запускаємо сцену при повному завантаженні сторінки
        window.addEventListener('DOMContentLoaded', initScene);
    </script>
</body>
</html>
