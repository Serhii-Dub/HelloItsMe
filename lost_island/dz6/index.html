<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>AR Geometry Calculator</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }
        a-scene {
            width: 100%;
            height: 100%;
            display: block;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/aframe@1.4.2/dist/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.2/dist/mindar-image-aframe.prod.js"></script>
</head>
<body>
    <a-scene mindar-image="imageTargetSrc: https://raw.githubusercontent.com/hiukim/mind-ar-js/master/examples/image-tracking/assets/card-example/card.mind;"
             vr-mode-ui="enabled: false"
             renderer="logarithmicDepthBuffer: true;">

        <!-- Маркери A, B, C, D -->
        <a-entity mindar-image-target="targetIndex: 0" id="A">
            <a-sphere color="red" radius="0.10"></a-sphere>
            <a-entity id="AB"></a-entity>
            <a-entity id="AC"></a-entity>
            <a-entity id="AD"></a-entity>
            <a-text id="PS" color="yellow" value="Place markers A, B, C, D" position="0 0.3 0" rotation="-90 0 0"></a-text>
        </a-entity>

        <a-entity mindar-image-target="targetIndex: 1" id="B">
            <a-sphere color="blue" radius="0.10"></a-sphere>
            <a-entity id="BC"></a-entity>
            <a-entity id="BD"></a-entity>
        </a-entity>

        <a-entity mindar-image-target="targetIndex: 2" id="C">
            <a-sphere color="green" radius="0.10"></a-sphere>
            <a-entity id="CD"></a-entity>
        </a-entity>

        <a-entity mindar-image-target="targetIndex: 3" id="D">
            <a-sphere color="yellow" radius="0.10"></a-sphere>
        </a-entity>

        <a-entity camera></a-entity>
        <a-entity run></a-entity>
    </a-scene>

    <script>
        // 1. Зберігаємо стан маркерів (тільки A, B, C, D)
        let markerVisible = { A: false, B: false, C: false, D: false };
        let coord = { 
            A: new THREE.Vector3(), 
            B: new THREE.Vector3(), 
            C: new THREE.Vector3(), 
            D: new THREE.Vector3() 
        };

        // 2. Реєструємо компонент для подій маркерів (аналогічно до коду викладача)
        AFRAME.registerComponent('registerevents', {
            init: function () {
                let marker = this.el;
                marker.addEventListener('targetFound', function() {
                    markerVisible[marker.id] = true;
                    console.log(marker.id, " знайдено");
                });
                marker.addEventListener('targetLost', function() {
                    markerVisible[marker.id] = false;
                    console.log(marker.id, " втрачено");
                });
            }
        });

        // 3. Основний компонент для обчислень (адаптовано з коду викладача)
        AFRAME.registerComponent('run', {
            init: function () {
                // Отримуємо посилання на об'єкти (тільки A, B, C, D)
                this.A = document.getElementById("A").object3D;
                this.B = document.getElementById("B").object3D;
                this.C = document.getElementById("C").object3D;
                this.D = document.getElementById("D").object3D;
                
                // Лінії між маркерами (тільки потрібні для A, B, C, D)
                this.AB = document.getElementById("AB").object3D;
                this.AC = document.getElementById("AC").object3D;
                this.AD = document.getElementById("AD").object3D;
                this.BC = document.getElementById("BC").object3D;
                this.BD = document.getElementById("BD").object3D;
                this.CD = document.getElementById("CD").object3D;

                // Створюємо лінії (циліндри) - аналогічно до коду викладача
                let material = new THREE.MeshLambertMaterial({color:0xFF0000});
                let geometry = new THREE.CylinderGeometry(0.05, 0.05, 1, 12);
                
                geometry.applyMatrix4(new THREE.Matrix4().makeTranslation(0, 0.5, 0));
                geometry.applyMatrix4(new THREE.Matrix4().makeRotationX(THREE.MathUtils.degToRad(90)));
                
                this.cAB = new THREE.Mesh(geometry, material); this.AB.add(this.cAB); this.cAB.visible = false;
                this.cAC = new THREE.Mesh(geometry, material); this.AC.add(this.cAC); this.cAC.visible = false;
                this.cAD = new THREE.Mesh(geometry, material); this.AD.add(this.cAD); this.cAD.visible = false;
                this.cBC = new THREE.Mesh(geometry, material); this.BC.add(this.cBC); this.cBC.visible = false;
                this.cBD = new THREE.Mesh(geometry, material); this.BD.add(this.cBD); this.cBD.visible = false;
                this.cCD = new THREE.Mesh(geometry, material); this.CD.add(this.cCD); this.cCD.visible = false;

                console.log("Ініціалізація завершена");
            },
            
            tick: function () {
                // Оновлюємо координати (тільки A, B, C, D)
                this.A.getWorldPosition(coord['A']);
                this.B.getWorldPosition(coord['B']);
                this.C.getWorldPosition(coord['C']);
                this.D.getWorldPosition(coord['D']);

                // Оновлюємо видимість ліній (спрощено, без F, G)
                if(!markerVisible["A"]) {
                    this.cAB.visible = false;
                    this.cAC.visible = false;
                    this.cAD.visible = false;
                }
                if(!markerVisible["B"]) {
                    this.cAB.visible = false;
                    this.cBC.visible = false;
                    this.cBD.visible = false;
                }
                if(!markerVisible["C"]) {
                    this.cAC.visible = false;
                    this.cBC.visible = false;
                    this.cCD.visible = false;
                }
                if(!markerVisible["D"]) {
                    this.cAD.visible = false;
                    this.cBD.visible = false;
                    this.cCD.visible = false;
                }

                // Оновлюємо лінії між видимими маркерами
                if(markerVisible["A"] && markerVisible["B"]) {
                    let distance = coord['A'].distanceTo(coord['B']);
                    this.AB.lookAt(coord['B']);
                    this.cAB.scale.set(1,1,distance);
                    this.cAB.visible = true;
                }
                if(markerVisible["A"] && markerVisible["C"]) {
                    let distance = coord['A'].distanceTo(coord['C']);
                    this.AC.lookAt(coord['C']);
                    this.cAC.scale.set(1,1,distance);
                    this.cAC.visible = true;
                }
                if(markerVisible["A"] && markerVisible["D"]) {
                    let distance = coord['A'].distanceTo(coord['D']);
                    this.AD.lookAt(coord['D']);
                    this.cAD.scale.set(1,1,distance);
                    this.cAD.visible = true;
                }
                if(markerVisible["B"] && markerVisible["C"]) {
                    let distance = coord['B'].distanceTo(coord['C']);
                    this.BC.lookAt(coord['C']);
                    this.cBC.scale.set(1,1,distance);
                    this.cBC.visible = true;
                }
                if(markerVisible["B"] && markerVisible["D"]) {
                    let distance = coord['B'].distanceTo(coord['D']);
                    this.BD.lookAt(coord['D']);
                    this.cBD.scale.set(1,1,distance);
                    this.cBD.visible = true;
                }
                if(markerVisible["C"] && markerVisible["D"]) {
                    let distance = coord['C'].distanceTo(coord['D']);
                    this.CD.lookAt(coord['D']);
                    this.cCD.scale.set(1,1,distance);
                    this.cCD.visible = true;
                }

                // Розширені обчислення для чотирикутника та всіх трикутників
                if(markerVisible["A"] && markerVisible["B"] && markerVisible["C"] && markerVisible["D"]) {
                    // Довжини сторін чотирикутника
                    const lenAB = coord['A'].distanceTo(coord['B']);
                    const lenBC = coord['B'].distanceTo(coord['C']);
                    const lenCD = coord['C'].distanceTo(coord['D']);
                    const lenDA = coord['D'].distanceTo(coord['A']);
                    
                    // Довжини діагоналей
                    const lenAC = coord['A'].distanceTo(coord['C']);
                    const lenBD = coord['B'].distanceTo(coord['D']);
                    
                    // Периметр чотирикутника
                    const perimeter = lenAB + lenBC + lenCD + lenDA;
                    
                    // Функція для площі трикутника за формулою Герона
                    const triangleArea = (a, b, c) => {
                        const p = (a + b + c) / 2;
                        return Math.sqrt(p * (p - a) * (p - b) * (p - c));
                    };
                    
                    // Площі всіх можливих трикутників
                    const areaABC = triangleArea(lenAB, lenBC, lenAC);
                    const areaABD = triangleArea(lenAB, lenBD, lenDA);
                    const areaACD = triangleArea(lenAC, lenCD, lenDA);
                    const areaBCD = triangleArea(lenBC, lenCD, lenBD);
                    
                    // Оновлюємо текст з результатами
                    const PS = document.getElementById("PS");
                    PS.setAttribute("value", 
                        `Периметр: ${perimeter.toFixed(2)}\n` +
                        `Площі трикутників:\n` +
                        `ABC: ${areaABC.toFixed(2)}\n` +
                        `ABD: ${areaABD.toFixed(2)}\n` +
                        `ACD: ${areaACD.toFixed(2)}\n` +
                        `BCD: ${areaBCD.toFixed(2)}`
                    );
                }
            }
        });
    </script>
</body>
</html>
