<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>AR Чотирикутник на маркерах</title>
    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.0/dist/mindar-image-aframe.prod.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
        a-scene {
            width: 100%;
            height: 100vh;
        }
        #info-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 10px;
            font-family: Arial, sans-serif;
            max-width: 300px;
            z-index: 10000;
        }
        .marker-label {
            font-size: 0.5em;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 0.2em;
            border-radius: 0.2em;
            white-space: nowrap;
        }
    </style>
</head>
<body>
    <a-scene mindar-image="imageTargetSrc: targets.mind; autoStart: true;" vr-mode-ui="enabled: false" renderer="colorManagement: true;">

        <a-assets>
            <img id="markerA" src="markerA.png">
            <img id="markerB" src="markerB.png">
            <img id="markerC" src="markerC.png">
            <img id="markerD" src="markerD.png">
        </a-assets>

        <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>

        <!-- Маркери -->
        <a-entity mindar-image-target="targetIndex: 0" id="markerA-entity">
            <a-plane src="#markerA" width="0.5" height="0.5" position="0 0 0" rotation="-90 0 0"></a-plane>
            <a-entity position="0 0.01 0" text="value: A; align: center; color: white; width: 5" class="marker-label"></a-entity>
        </a-entity>

        <a-entity mindar-image-target="targetIndex: 1" id="markerB-entity">
            <a-plane src="#markerB" width="0.5" height="0.5" position="0 0 0" rotation="-90 0 0"></a-plane>
            <a-entity position="0 0.01 0" text="value: B; align: center; color: white; width: 5" class="marker-label"></a-entity>
        </a-entity>

        <a-entity mindar-image-target="targetIndex: 2" id="markerC-entity">
            <a-plane src="#markerC" width="0.5" height="0.5" position="0 0 0" rotation="-90 0 0"></a-plane>
            <a-entity position="0 0.01 0" text="value: C; align: center; color: white; width: 5" class="marker-label"></a-entity>
        </a-entity>

        <a-entity mindar-image-target="targetIndex: 3" id="markerD-entity">
            <a-plane src="#markerD" width="0.5" height="0.5" position="0 0 0" rotation="-90 0 0"></a-plane>
            <a-entity position="0 0.01 0" text="value: D; align: center; color: white; width: 5" class="marker-label"></a-entity>
        </a-entity>

        <!-- Лінії між маркерами -->
        <a-entity id="lines"></a-entity>

        <!-- Панель інформації -->
        <div id="info-panel">
            <h3>Геометричні обчислення</h3>
            <p id="perimeter">Периметр: -</p>
            <p id="areas">Площі трикутників: -</p>
        </div>
    </a-scene>

    <script>
        // Масив для зберігання позицій маркерів
        const markerPositions = {
            A: null,
            B: null,
            C: null,
            D: null
        };

        // Функція для отримання позиції маркера
        function getMarkerPosition(markerId) {
            const entity = document.getElementById(markerId);
            if (!entity || !entity.object3D.visible) return null;
            
            const position = new THREE.Vector3();
            entity.object3D.getWorldPosition(position);
            return position;
        }

        // Функція для оновлення позицій маркерів
        function updateMarkerPositions() {
            markerPositions.A = getMarkerPosition('markerA-entity');
            markerPositions.B = getMarkerPosition('markerB-entity');
            markerPositions.C = getMarkerPosition('markerC-entity');
            markerPositions.D = getMarkerPosition('markerD-entity');
            
            updateLinesAndCalculations();
        }

        // Функція для відстані між точками
        function distance(p1, p2) {
            if (!p1 || !p2) return 0;
            return Math.sqrt(
                Math.pow(p2.x - p1.x, 2) + 
                Math.pow(p2.y - p1.y, 2) + 
                Math.pow(p2.z - p1.z, 2)
            );
        }

        // Функція для площі трикутника за формулою Герона
        function triangleArea(a, b, c) {
            const ab = distance(a, b);
            const bc = distance(b, c);
            const ca = distance(c, a);
            
            if (ab === 0 || bc === 0 || ca === 0) return 0;
            
            const s = (ab + bc + ca) / 2;
            return Math.sqrt(s * (s - ab) * (s - bc) * (s - ca));
        }

        // Функція для оновлення ліній та обчислень
        function updateLinesAndCalculations() {
            const linesContainer = document.getElementById('lines');
            linesContainer.innerHTML = '';
            
            // Перевірка, чи всі маркери виявлені
            const allMarkersDetected = Object.values(markerPositions).every(pos => pos !== null);
            
            if (!allMarkersDetected) {
                document.getElementById('perimeter').textContent = "Периметр: не всі маркери виявлені";
                document.getElementById('areas').textContent = "Площі трикутників: не всі маркери виявлені";
                return;
            }
            
            // Відображення ліній між маркерами
            const connections = [
                ['A', 'B'], ['B', 'C'], ['C', 'D'], ['D', 'A']
            ];
            
            connections.forEach(([start, end]) => {
                const p1 = markerPositions[start];
                const p2 = markerPositions[end];
                
                const length = distance(p1, p2);
                const midpoint = {
                    x: (p1.x + p2.x) / 2,
                    y: (p1.y + p2.y) / 2,
                    z: (p1.z + p2.z) / 2
                };
                
                // Напрямок лінії
                const direction = new THREE.Vector3().subVectors(p2, p1).normalize();
                const rotation = new THREE.Euler().setFromUnitVectors(
                    new THREE.Vector3(0, 1, 0),
                    direction
                );
                
                const line = document.createElement('a-entity');
                line.setAttribute('geometry', {
                    primitive: 'cylinder',
                    radius: 0.01,
                    height: length
                });
                line.setAttribute('material', {
                    color: '#00FF00',
                    opacity: 0.8
                });
                line.setAttribute('position', {
                    x: midpoint.x,
                    y: midpoint.y + 0.01,
                    z: midpoint.z
                });
                line.setAttribute('rotation', {
                    x: rotation.x * (180 / Math.PI),
                    y: rotation.y * (180 / Math.PI),
                    z: rotation.z * (180 / Math.PI)
                });
                
                linesContainer.appendChild(line);
            });
            
            // Обчислення периметра
            let perimeter = 0;
            perimeter += distance(markerPositions.A, markerPositions.B);
            perimeter += distance(markerPositions.B, markerPositions.C);
            perimeter += distance(markerPositions.C, markerPositions.D);
            perimeter += distance(markerPositions.D, markerPositions.A);
            
            document.getElementById('perimeter').textContent = `Периметр: ${perimeter.toFixed(2)} м`;
            
            // Обчислення площ трикутників
            const triangles = [
                ['A', 'B', 'C'],
                ['A', 'B', 'D'],
                ['A', 'C', 'D'],
                ['B', 'C', 'D']
            ];
            
            let areasText = "Площі трикутників:<br>";
            
            triangles.forEach(([a, b, c]) => {
                const area = triangleArea(
                    markerPositions[a],
                    markerPositions[b],
                    markerPositions[c]
                );
                areasText += `${a}${b}${c}: ${area.toFixed(2)} м²<br>`;
            });
            
            document.getElementById('areas').innerHTML = areasText;
        }

        // Оновлюємо позиції при зміні сцени
        const scene = document.querySelector('a-scene');
        scene.addEventListener('renderstart', function() {
            setInterval(updateMarkerPositions, 100);
        });
    </script>
</body>
</html>
